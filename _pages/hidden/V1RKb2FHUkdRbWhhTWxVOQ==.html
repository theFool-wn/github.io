---
permalink: /hidden/V1RKb2FHUkdRbWhhTWxVOQ==/
---

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Hidden Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="https://wangnan.net/assets/image/hidden.png">

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #267cb9;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #267cb9;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #e5e2e2;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Hidden Page</p>
                        <p><p>Access with Password</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="show"
                                title="show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="CONFIRM" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Wrong Password",
                templateToggleAltShow = "show",
                templateToggleAltHide = "hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1abac67104ac986fa2cfc465a77b45b6802d5942096feeac4fd39ade97453ef530e6c12f31eeaa7495aec2ff29492688145c3a8efcc86e9d07f3479e3448458cc3667672742cf9c81eb565315a11e1a76d12cc36689b45b36312a9140b65b866971f2774f5eb4ad76e6ca8bdadc301247fba89d4fc945982b6a4edac8b57bcf72d3dc35bd09b3f0510364dc3d425deedffb95db474fcb02d629ced311e183c6bbbe1da885793fe1d3077b7f1d22943faf29ddeb4d0e17028be5d1a5f54f5ae50d1e337db0dbce075e967a3ceb87d301d81b0db4cc05bcf40d3e5e568e34956d9573011de2b5d9ba854a763b9d6335a880a50bb668bf96b4a810b39fd4adae4b7119ccd39801e9de5ed566b4b0073ffd05052dc474428ba65b7a6a2131f24b68511b3bebd118afdf122b0cce60ea2aafb03eab2befd58b48ab3c239104cf4efccb39ff0b2c3d4cda8e20edd5d5b168a4089b3a902dbbf99abc95ee14a16c6d82b85b884baf8faea0df8bfd299d1f91de278add1e7b004762504864404477b69b5eb823f64e3bdb5e63b75d4ee5a44d18ab5f2917253d89f7049cf77200ad4d429491f88a8f61a3b674e53d668b61e86f4b94bbbe3d222a0543f57383923643a6828a8e5d94e00917877f25495a28f83d1ab99345e5274b6303ae871eccc0966541481a161dfead6623b9b998d5f70f2ece7c83ddfd2dd6f1f1fad8f2fb7f633bf020e11028653864f09dc2f6821cee6e016db5118252a93066d6f67facb4854e6e2f26e417cea6361b39aee6276990246fa7fc3259207419125b8a2097ae999ebd1390007bd8e280699842f6b0903cffc97b5edcc05318ba8423a3b4a0978557faf50d90da3d45e3663b316f0cce30bc10b410846229ea5e032a56ff96342fe740c5001e5b86bc8914c3d041cebe084d44ebe69d62f8c6e6e7ba1bffc2272baaea447e1fd7eea9fbd84cf188bbfc3a2eb359625fc31ef917ce715b10fd70cfc4932e5b195f0b0101a4c34cc046ec07a9a6831ae13657bffb65b8adb0e17d29c2498c1a3f09ed9f763bf19365ba51c3a21f6b60d648128ab56964e1e97826f8cf272f9e71242f60219624494a8bdd9abd481f607d3e73ba856d86419704d62a559fbfd5301b42266ee43b93b681a9b7c2497f0c392c928fe53fc14cac3edaf343135f7697fa6cf96d21a61834ca21dc9e2e2de7f6c64bb07646d0bfd1b1e17424d9afef26dfdce46645fd760c65e67f36466fd548d4b7d9ff59fe5c635f9cf9ee0732149675eabb9e1974c4f7f55bbb426c816d759a70718de513d151fa857890c48c6bad57fcb3c1f7e12f806de30e046ef5525089f1cc82e822defd835e85c1e6cfc13f681a89cdc4dba01333b7537d993e9f79aad2c91749171f75e8124104ed79c097d23a59e648b9784730053d4beba3fbeae90cd80fdbe5e10537cb4fc84d9b67bb8cacab695f97ec0cc15a7b25079b4ba9e2a655a62ebae239ebc4cac40b9c093fa263cf7a1076be1e958f47f511684c88361ccd07a0f4c5df66b921917fe5a8ebebbb70388257b814fc474bbb0f51d35a35e525eebf6119aacc855d27d620df10271ffdf86c08d03bb75b52d83a988b1be80417b96ea606c173c6e733a6f79662695474aa5db95cf4db0f81a186b8f4b80276943a94ae99431e709306af44c50a90a937bfe093f7642cff39d2cc85a7506a5be883b3d7ab21b95ec36e2db0cbaec0cab65d81324bee1dd13ed3af33f0128d1ba666c4287dd84eb18d38ad3c3d4da2debf93ef915e0bf951c12f356f64de6c80a70e5e7c7c47962f61c975caf781cdaca9d9945eeaec5b00e10967d62c2819558c4daef082b7b76617375e5537c6c1d5bd91d33218d1c2186673542bd183f5d01681b0d05e31df9a1b9f9587368bd08984c9b948811c96094d17594d5710a5718cbe83e8d73aba9b135dec9d164161bdbb57b433f608e90b06a1aa2e472419c81baf558f1eb50c1cdf8d1580496ef348b9aeb3ea97368b7be375da9804d2388711d5e6c452f04618d1e2d3da2593655653a5f8a4883b357649971d81f42b822b5868f46146e31c537959b19f4bd146d332c1b85fe17355d86751f0842e9440bf8c70fe1180580861811dc5df075612c2b4c5576993a86e2ea4125cc1cbf3650c3a2dacfd76ddc861e7e07000dad97470483d4f4f80a8a5059df25336b8512d00042ae41be00d6542b8dc1ee5b74623bb49d49ed3e348cf4224157bd1f880254fa9aa30401c87124f940178a2564e89f79924786d30b66909068fc7a6d549f3f65cf3445fedcecdeacd8ccb7407ad5de6c4f83c1ef8ed2d2f9071fa8224bc613eb9c29ce4cb7143e960e84000cc3751e4e5cb8fe88c2d0997f850439d6d5930de6127f4f94797ee056145d4cfc7ec7f4f58d096da42afdcf82cf2b021c48f934587a0ddeeb2388d4c857b5f27e61fd6c0f1b85953adf5658a0eddfabc7b27df76578795f9fcc07438afd00b0fd607a3bcba1ff306b3912b50a9524849ba0b210359b68ec1aad06168bcab4bf62247350b2f4962d323a67e9c0394cc890ab037275ce5dafc2e18909d5625f47f593272d491dd776a795fe51248c10d8d323825179c1a1a8b9de756d1c25c64b8f18ca3d3322cb599795a885ebf7ea012a1893202e6aed7d9ced40dac0912952f74c73a3c0cda23723c2e7d3b7bcd39b5e2a52cb739a5fed34a5747d4ec3219743927bcce3033f980cdeacba3446c74080ca0cf772b1415447c9d3795f36e46a4c749f511c9e6c3940c7b309b9ef807e4b0fc9328d602d61d7a34548865bf21ca4fc8c16c39fd28d401230c1fa4425f28d869cc0934dc5329fe28f5de2e17d0bdf4b2ca9213a32a94b5c7dce6038e281b7871c8703b1bddda3851b552a3af99768bd74727d2e14c4d5ece4f686a55d6fdcc017882d5d6ea2c4db2929cd3504dca08e369c1e4469e839fe053855cedeb9ee51fa5dee4ade3e23d6ae70dfc18b9072b91bc810d46051d8fbe32522087f6825cf43f07c13b9099732e513204162dd612b60723200687db36294115025252ef05904f31b8e4de4e5c2cd90b7a8625c4c672281de3cf6e84671d3b6f96160c5481ac3c6d71ab50869779ec3820981070b9d5cbf8eacbb6dc3412838267cb82c744602480e809a1dfec7af73423d9cf471401339bd5def8c2099d3d5eed379aaa8b6c5921444719fb35b9b6aecb72bdd2f6ded776f5446b417226b997fe06f53a25fc0a9d06df8eb67d4c641a132a9f0c3ef1ea8ee8e38c0bed49b544895c697727a38a50204d4af1ce7032b13838b26c29ed35f65aa43b70b8cf9e347439af734bacb43335d4484d64022e73f228647eb6fb2a8a5728a7bb77afd444665cdd216f80fc40c3e713faf0b866e19a70aec3929129cf7ad33579576fc1867f35490fcc5a6c54fffda614e442e4d8859b664ec3e44e702a46858024155eab083a9998bb6377fef21267db0e0709d7f45827da7a7ecaa8dca1f50d86e7303298da54b527817dacb45d3ac8523d6def5ac553f5c081795b9eebb9aad220a698e149f116056611162fa9569d19beaf54e1046324b0afb953df67bb424d67a19c9c7cc6675f8cadd02db0ee6a26627cb6c3170ca071d29d421a868724ca34e46ee9fff44643dd207dab454794115bac31e07dc4564d299df30869eec87e408cef9ef241c5776016b88ef68c1948139eae016edd2b58646588be57e5fc7784f00ba04574c69d13a1629cf9724cf5c17a470e4cf48f787ce44521e28b0c2b0c8d50be8c7d7b9465b06c280f95c0ec5fc6b1a03c3059a16739719f07ce63d73b8c61aa0a154f3e32ad58f4fafc4d4e3e41505563220fb757aa51ca4c105c697eece670c82256fae3659a1ddd9d1f60da2bbada4541da50368ad104d5c72d0c64b789a0c9a4cecb989b75234624e88f3af390fa68026335cb801485ba126baeaae5ab3ebb40de535bc69da7985ab1d32f9db8a0ff4b66379bb35dcff3b83e813087393414264b9633b5c8a2999922273f666a524472681cc0681563943ebf65efe4ed396c1220bb1e1089f139d949d1af90ad7a581ca1f59acf453f6e1a665911474e6a92d9473a4fe39fe0498049bf10187ed8d7c29886996ebf39d4eae834581cb94ad9111071099e48be977ffb88fd194ea9eb0a48d71c81c3911e7052c290b5414e8473dd924fb36fddcdce5292ce5290888558776f3ffe1f9bd854dcc988ac82f84a8df79930fe75f353965cf144465666b9e7520a9fd389f131b1b575c6e6f86351cd66d610dde1961c0a9b034cea3839a58edd0f11cbc601a8794a389f625a18b52ce9bebf66f02d2cb1078d67369251b0a6161e88f5b65a3f33215ab8e733d13039746bb5243ff602ea60567f1653d8043334f12676fd2cdf0c0168fe2401f201a37f96d6a90827b4824717f95d1d723345e6a40510411fefe704d6dc2ea8a11b9202636dfe0338a6c311fb8fcb9393314cd73092ac192fb3b9166abfcee09b15573474d134ff73236e2c3f7249306b359d9934c9eae2d4086577375c9219ec8dee7089b23af394191f75feda2d4203dc445c8fa9beaf6234426831620b07f127af53eff3a4b030fd76a537ae19d05a6e9544324e0e5821c9d0b9d1d6c28d195cd84e73b39a10b2e094452216880452eb607212978fc1a4f8376d739babaf7527dee89c00a6c2843b0cdb81ede6bca0d63ee168d3026a535aa9b12df911532562824447cf9b0521d404af8e80c192062a434aae44b3e49dd098e32b5155d6fef690629081d1e964aa34ebda32a64facb5c80c39c32f3d8fe6107a1e92741d84475b57e542f131926f5ab58584f19440eb244610dd0e0edf8a932721736bec8bc63c5af926fa2ad655afc2faff46b612f9b702d4f2e081dbc7a7c795cd10ecdd68103834a0722b543d7d491b23baa839c278f7b44da0e34d0291e1af1de30c507b9283affbb9512fec95a2dc3404b0886a87701980ba4fc53139f7ce486c426f2a281362ba49a22bf252f89f341f3cae6b5684ea3478f123b34a0f92262618db8c6a70768a99b91ffdbb6ea5462e75bb14eb5e0fb60e4620bb173c3f77053f10e78b986cde738ad0bc035385bda9e335164d3b08a87ae326ee0ce5bfd6a54015e4a03f3e8ac0c09fa1115b8e5fc285f4cc9b8e504d66e69993620c3a7a4e7b916f7e8075dedb9b6f381bf49425ee8962cbff85724dae521299405a66ca16dd4eb5787442f27a98d50ea6e25665b0afedab4d3fc4eb5ccdcf2ce688ac853237231719c01411055478c878ad8f4c90bd46eb9c7b97e626a02088857cd8678f48ac648102c27d5b91d4140ed242ebabc1ae3b4509dab4017c9f3d95a7334b40e87464d554411e9d846729860841ace8c597e6643efdb6e43f909637fedbebf766a45d99b9a2539344311c7dc88474f40b117db6bdd18dd905cfb4035a58203ade65a8d82690e915dab31899cf46a10c8f308e9b8c67e419433cb62a0fc3dfbb7db2f2042753a6ca2684d9f2258f7909872e35b990abe81f113bc3c96c530e1b5372c0e68043c50b2177dc797acd4508dbec7df16f33118d6ae639c50153ee3d0194a380f55d2f2a6405e1a3a978d311f8732f03e3b99ebc2099a22b6e5ea997053e4a1bf6808b2b744e0497d16fc977ae2b9142f3652e52eada7599e04cb1a6e5bd3bb7492cb5c0eec7c10b1fd849b721929ae9e41703fac0de00a8ad2bed41d11ee2bc7721af24ed2c8f7317f5d18010b3e2e1719ceb8adee3abfc962f9c5f6c4d7faa4a3e7cd35a6206445d96e37bb5d32e8295f6ca54a2afa772ec4afdcd4074a2f4ead8c292680179ddf0b55a0823854ac48381bf73cde8b042c829659b968c78abbc0ac973d9c0ce9c6cacb046789c8fe15b4a82a7906012533aeadf8a30e57b4746cb7af65e31b4fa1bfd517b2ffdcb444179ba99a4c1351b90e3980a96de33d55285633016c004afceaa58edab8628c1b33ae48cccf77ed2fa47e17cba03f6b9cc2fa3fec10b98b3d932f0f0e90e90888416a67d0282029028551e3c12246759fc6a75a200ef52763152c4c8876ee1fe29185d8e26eba6935a000370ce5cefe8c7efcb02ad06c6d76e8069084cbbbde50ef311cdf53e6414be310ad5803e5519545540ff73b980f5f83421037a892401cc4b990454aabeb750ddeff39d9e17ba69e84eaa82f54bde909450e7e1cc334d4eaa24d9c790227960ff4b0ecb89b8e3c026c105f2a660e8300d09787b795cd4508ff0d1a0c8e264c647eb6b3e85fbed0f48811f6719c5e571343d8eed9f49b19444a903734734edddbf75ae45cdbeda4591be788b822bd348f81de8a283d8e1ca851213ff6b629404d9c9b7f38a1f2f951338154480cc902a1fc51f4b2c3a040939daa4b710c80e0298f2654f5b1f16d89b50fbfb74da8e502d29b4f366f068ff0bf6797013c617b3d3b247977641f32006a9e17599777ad78d7f77f3457b46bbad0b792b9a68c09d9ccd3f6f9dd33d5598c46664e0b7ae8ae6a99f04271496cb558b56058a8abe51ffb407dacc226c3d430d560e0c340fbfe85b7d2dea46356fc52b98e67411737db43e0cb52740c25c874888dbc64768582f29a8d02d2b086c80ac57ef669f7f1a23eb14f7948d02c4df77633e31bb7af30ae661fe3b7fb6c6f55929fd877b0550f5a82fed435098a21d0bb42979ce155db5acc523538add9e784a49e5a2f001fcc57da2a032ff988a06ef7b90b23c7b18bd3aa3094c9e58b8a9b54bcc8ca50ad202beca075b963885f37a1525a5ab2937b9e8d1255ed763089d0a5be5db9d3e97dfa1f40ac6c91b1966bfc5960b231ff09f71f364e40d6ce41c4e32858e209bec6be39c16293ddfb6a70215911e66a339648ffa2a90de3a290ae54cdbcd0b5bb8cee5b3734d305fb3d23163ce9de07dd0672dd6db45d8bb5f1eadb9293496604487584562067496d5d0503e2c84fa84b695f84d6d6da4090fabe04dcda11b5876487a06d5ed1de4d5b676473095f408985d5655090755021c9663f4ec2f8ccd431c7fa70ba7d4fcf4c70a5f2fe6b3ded0d2e076e3eff075eedc706c6a1e9d6f39b126489c9b95d13aa58ad1890a686d2b2030e65f8eb102d6241cb399d9fce75839065e39efec953c9a226e4a28cbbfe6ab8b7a3148d7d9fa145ba9fe4a058ebbb80569336fcf4cff343fa86cd0f393c9053c3072c575f862788ba2bcb772ce392ba3e54baa1ed6f18b6f19fa677e97c1a62bee0dc48ac431bc7624a7777e4b3cd9407955ad563b05b4e9a9d229a7e65b815e4ea42cf52ef1a3e3d385cd9ff904c7b04fc8dddcdb5940727de3f3de0d9d64e7d37f92f2007b3fc3d0b6ddfac41116f7f77fcf3736679a9384b5ec7487d14ecafdb7aa58b437d427f10c9a76fc57a3d97b8e024595e3c00c5504eb52d34df07f35c9e22e8e832eea849ecfd9dd8247a3d0892e11f894761e74c3c8b546acb076e6b094b16809ba41f155fb1dad2356c65d7813d16d062a3b4c8d0710adce78e46fdd656ca92cf51e55b9e9b5369f67814f708ce41326203f888e58b9778cd5c063dd013a892bc51f461de85e450097dbc86fcd435457df4d36e5df2171975f23d2089bfed501b5f6999565e2ffaa7d135365b30d2264aadc13c57202213254a5d0283dd0c6a3e45627284d733c25412fd01ad210419ca8bc519c9412b9b38ea32b85e6322f2ab10af81ce4d68e2b6b7f8857f2428efc6e605fad51abace2b3bab327380b3b7c3ac4406eb0779395bca869927fca91f133ea6a829649ff1ee37979b4bc414479f7196025f7dc0985612a9579b5a5a9b1e19a410a83a73d31ffde60a2e5fe867c2345f414a5f40a47e0da772e0debd6b1bdbe787b52e57482d1f19014574386113409edfa7f5363fe536bc8fc72b7699d706870313ee0c07dfe5fc2dbf8976a60d5f50459255be651300b7f9b06058f73e81df7dd43f56541cbd91fd700029f073e94837e5d1c118ebf6e0709b0e9379d9cc1ffdb46fc41468f9fe10676e713f6acbede2ff6d73ecbfb105f1225560a170de9cb42a5969b0a4a94b539b06ad7f987eef5818d4952d78be18a08b5e1361df54c162b780edc72c6d167cecf713062732850050e72425914d5db81e992d6d45fd11b066fcafb682ce3361c60d490119053db61d6e62d2b22dacbaa9a366672ed4144a305a63d9e32d2564de5d0cc70dd234e24b1da7743594c64066ec2b22b09a8dc8d7ceb3c0ac7d28eaad2f78b15a12585c14fb0d9cb3002f8a83307f01edbbf6baec344982f39f22bc50ec29bdf2cf38f43eac4346a7a641a9762f6cacad90d897d9b459c57f671854c5b8ed811b9ba9817db1bdad849f0d69713077158f9f6db978daf19eaca5149c9ebcdb7d5e3b66c0d1427878b0a29b43a69a6953441a5a233f09d284558f9b57f91ce90cbcfbd079215fb33200eba58cb61a495f4c064cdfe39e88a67f09bb209e97cad30ef347dbe69a99997c1dd9489b5cf8aad8c3d2aa608accfe740db7e5a80372","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a0e6e96a27f0d2e49d7726a2ef71de68"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
