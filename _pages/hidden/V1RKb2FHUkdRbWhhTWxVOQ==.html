---
permalink: /hidden/V1RKb2FHUkdRbWhhTWxVOQ==/
---

<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Hidden Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="https://wangnan.net/assets/image/hidden.png">

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #267cb9;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #267cb9;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #e5e2e2;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Hidden Page</p>
                        <p><p>Access with Password</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="show"
                                title="show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="CONFIRM" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Wrong Password",
                templateToggleAltShow = "show",
                templateToggleAltHide = "hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26355bd6f6b3a7735b7b5a5815568265855a0474359f6407cd0afe86d042c8e7e0a76953d40eec32347bcf4ef092a3c4b30c372b50942ad2b864fd57a34e564a9bc8a8f6688ec4476efd1a2aa16d2a72fe1902036d293d19dbe1946d19be6def6372ead4503a99fb22d98324faa853b94a4ce7f0d555cf6a932907b81e0f37a58b76ae1e7f143305b34527ea415368fc948581b0a79dbf7e56ca56a83a59ed4380faa66bb082474f5b853a659acf08f526c700627c38ce2c5ddc88d30d3792e79abf066b69aad4b614622f5fc2e5b0f907b64412972f1198fd4fae9342b60b7fdafe83a332a92e093d83056c4108bcd013c9981bcabdbba9d903e1e814357693170c3c72cb84a7ddb4268de1f67aecd59032cc695200b56f781e2844f9f6a479d387dbd00267037fbcca6d23d9bb51fdd4a1631a587fbfc94e0f1e09c780bd5b9535f6dd0aa31de08fe1a0b2bf85565ee86ee6044a2c856620bccc7ae86143a76812ea827e78010272ee557d918f8510fbe08ddd7f38bb9d957890028ef1872e3c89f901084cc64e750908aa490409cceb1174ae7ca3c58d8c4da781cc9dd8c85d59c363dc5533c61191aaab917f826100c548c8201acb405b13802791d5455b1639d9dd65aec2701ccc7ad4ffbae8e436efd8a98d7b130e312f18a282afa9848057d31ce90bd907b9d1acae29d29002b516ccb38b099453b6053dede346f9d17b29fe32d34570a4e3926435e4a8f99b6ea185075670bfecf555fabf186defe4ba6e28f1362b34d3dba36879c93ec46c925a1b95b2adbcca5d9844ccaaf8236f731467c4da032fdd0f80e3a8abd7f8a5386ea271e25284f4f61618e912056f6d1ad4b5313121e9f59b56720c5dd33d6e3221c58be273e839402304eac2aaaba01aa43f5eae101d96788a441d9f20cc96b65a95e24a35f1f5107bd83da59862d80b4cc0c99e20260120e21de5838f1af3a443c2f0cb1fc0398740de1835012f0f4c03b8ede40fdc1f4caa228a3499b5b18f64b17c3226df3c1c5327da572a3d1d6b10aa44c3ee5b7e57b62db67de6db946eb3f4d2779ebb980eef2714bea6185493d8a5ca35c570255e1917705a000c1b76394fec322b628fe55b195b3cbfa4af4a56ea91bb603c496040320edfe24a4f98fb0e0015436a36cbd55bd5848e4624dc3a4253982c91fa0573893c2cd442ec254deee7aac49f3aece80ed183ba8e7bba37596eca6c68967dab0066a4da5ce28a04467502d2061b7b4ce5a320991f7f35aacf8c2da0f215115301edc7a27976ee5ed0034099f043b53dbca75e726be91facf861444a2e400496d09575a3269b9334e7cd826fc7e76f1ac2270976239103a721954f16c33f6ee2128b44ebcbf0f64736554cca5bc071ea9af193e2581b7e1f14250abedd21db5b0294c73346e98793b63b8f547eae8efb60b9f0ab32db7020f2f279fa59e35015f606b6ffb4d8af6afa79eea5611c27b6cde014ed9780b580af754521684aafe137bcfea1419174ab3ad52f2cfa863e6dc599bd4316942bf2d2fadd1ef93525bd51bc658a20b5671bcd1547a8c89db5544a8e0fad36a50828f273206170fd7161fe6bbd7eb36564aa5db311bf7b80addfc07f8d54cb0840f26d6ea3b5e77edb8dc9caa11ab085220bbcefe2fe3f926b08313f4f080b0c12de96f66d08ce2c558972c73516f8450351ec8d12f2bf9f44104e09a4a81f7babe7d4c10d9963e98e6a88b97e9c198d895c4d00e027439d446d611aa49e99ba4b2019dfe1d4a193a86bd6cf829ea3b10e2f69b3fa723f52190a36c85a52f809f74ea43579a3743317aa9eddcce4732c228085f207481ad688af21c03fd792d3599cfe4ad688c3ec63d6786c4b02e1ee08efb9875f2d58f4e1d39c1477d6f43efbff3f2564cd23fc4ac0dcb0b1a60ee3f0810692590121c8b5665f168c9f7eb018a26824858968c675352c768953c72ac8968a7bf4c6f4fbb2f3c84d1461f49219673a51634c997102147e4de6b931f4f1fd7e3bef8bcc78181cb32ad3111a25c2447387b060838099c713ddf82bb243ef2e1ab2da416ccae803ce41e02c1f6dfbb7c819ec67c9a372fcb51692678a4f62e9715e7b1288361919763e1d76220274492e4b31288f32592971c028238a5264b2630758613c006530b447f90721a02cea03b170bab7468cbd5c899d748a83baf371a3be5509033700d6ebfa1e40a0a66c16ac8d5fcdea9078b0cdec2176e0ef0c39c16e45ccafecc2425cc2d1d11fd80eafd7dcf71cd1441d588bc32c7e0c9e77ca27117856fa1cdd966c8861e5449c781d46b39cd1c6db708520e81d667e6fe2d881dae9caf0792777fc9c528a74bdddd1811d72395875638260c655efa728d42ac1435f7bcf6368c0e3253265bb159f2ec1a91ff0c7c866b13ebca8d2b0ba878d4989274f5d7541d11812fcd10630ccd1040f77923ae54bc448f0da0fea5a14aeedb5879df6ae3bace2d17669e9f56b8635fc9cbdeef9fc4843e8549b8fc4dea22ac19aba6075ebe0f45af44a2cf169458e5f43c2dd248f07b7266844c04d1e5a587dfccd275bdca839c84ba83d4725b91ba77f1590a71ca02be2ab0bd034633144ddbd74217c195efdd1f3c81fabde66e08442a32ef13ce32a70210bf14189faf075b9b8d9db6bdcfc1dadfc5c74da9a0e691c442edea6e278be569717b75c2d6db17ed3232cf7d4dec941a5979d58052b67b071076204f57029726f429be717a5282cb1df29fbccf8a7ec4c6f201282ddeba930a91998cdbb4e5229d90a3fbd6eb62d3203ae19f0af3e3ca24403bb2f1e4345ee2b73154ed3c16081ce6f471ec5f64bf6b1aedf41122c0a2daa058637bd317ab05663ea25fe50c378e787c9ce41dc6454bb3874614674dcbc1bce32d2f21f95fe43130ce005e35822dc87eb943e2b9670361128703fb4049f4d99fb45acd278cb1b6b0b7760bb5ce2321d9af8c3d49de0aa5b4706788a92db63843046dec9b9a9fd9c69486c3ed41ccddbc86d6d9f382b4578464aed131bb8961edbe36e5b05c7048b3ccefd0e6c32e0cd8792713f4f95ae3ce13f80208cb690675c741a1daac090d43653408ea76877a5208413f5b32aa0903bb32aae02614f0d33ad0a0843891367fe17eb3372c7072759b4b101d1fa6963b9600f2d2f5c00f786da0894f83f68dacb9391b42553f1169940c399d3b3c7040c969dfc15d067ffa4478d594b871229f3d53427000c2b4d5ee5398f54c4585bbc0b7a78eec43cd0ee4d5ee98969b6907f9116c01af1ad0b59c9e4c44805d00dc704ea2359374d8f23fc21867ad1d24e619f83254326a4830c77c932f41141cb13542c56cbfa39a68c4b5a0c4eabb847ef8f3a301cd1ae1b608f58724eae3132b9eaa27204a9fe4d0cad45268edda1da9f020e0ae6ba379917669137a635c884cd0fa4fdbcc4ad622f47f855a849dd94ba593cf5b4b0775a19f51bcfbd53bedbc6f4e1ca90889503b6128799ca54f9d347aec32d2f8190e20c737fd0539d519e09eb971fb021668d3c10422d20add86c3e83a122f46e654644332b9e5f87f7011179d6cffb9f1fbe60c474c81b00d46b6a53a8cff1b3a7dc31ba40b7678da63a94643205fc3bf590abed2a7d63c28ce3614207781d074130f4cb250b91a9b21bc62a326b27b1ccba47b126b843a44aac05491ceb1561d616ee67bfc5df5aa417ea86961c14f0a55d8681515a2f4ba44125bf328d4b08b350af26110d5470c2d1483d11c9f5b212a9bae6cb1e46f468855f49cf91da15d0f4d675d747c57be2a224e7ae4668a37fae68edde21027d1a3272ba846b4985bda26ddccbf342588b8520b1437c571d8945703947101c0fdc244bcad2f08d606661514fdb29932fd90be1da8c3497d85aca4fb12028cbf7579752ccc1c18ddd5ce0dcdf8ab65f1c028cd02d33fa3c5dce5d6d9bda9bd21d0b92781d2b781bd71481c63975cd1eea5f9161b3dc508d6139631a6adffc3d869f7b9372d6595bf609ad8a98a7c837d78167a9eab7e47de22af5d1bfb806fd0dc6feb64bd63217722c7cb49aa687595f9393aaa3934d878450073204b77189f9739ba28f1ae943e1723239a79838463cd9ab581e9400a42c2b2b72878eab78ea06eb1c46cf5e061dac4adfe8e1d91ffa20b16b5634c79fc38b356e8b78c867709f383631b360e6dd586cacbbf0aa9e05e0be0451b654417d3b3e0327f37e973678282e90cb4ad2bcdbde891bff3bb6a402deba19e2a9b9f60fbf4c2c17aa172c1a2357133afb7dd714a4ffaa92c505b283ea817c6dc366bf07f469e4112ccbec9a8aaff33b21c40e60c8f43c12970222a1e8d0d376d9aa9005a94d0c5a70a61fc38461ec770f524312052f9ee1baf5dea6ad187101c583ec095b89e3d9608c557a4ca601b8f9774483ff4fb1d86dd7cfb77f730ede06b0e7502ac5426790e8980a73b830b20aaff201861f1ffe3756f1e2223762ad2f27b9213c45f62d3c36f7fdd463d809db2ccd7bdf740233ad9b617b82ed5a4ddd463e5abacf517d9192b77ab2f6bacf69376c5581aebb222e3fde7510cfbb30c1612699039b3c417ee3ca2aa207f24115f2b3f081f38dc0c70ff127a1b0042d256dc28579df0aaf1dce7ebbbbad03094ee20dadeeadea765e2e362240f50ffd21b4efc0e56993fdd8755c10000ce5d901dd891cdb14a7e481e0fb84169b5863eb53d0c9563490a5997c364343c38441c80d79c845f1bd0fde947342cd09df38a9252db181d90b006d560d8bc32da61c2c3561a8ab5075e090b0f1d5668fb7ce0c8d2611a4aecb2ceeeea5738a04b5e61c76bf520305e4c5b3898f8969a50c900f4c418107b9aaeb25c8a8bd1dd1875e4c675920d371ecfed55224cbf45748d0e792e02c03b41c5773c98b01608d02a4136a9d77650a2b808dc000af5567a7ca2601495dbbde6dfb509350c44c006947406cd5ffe1c13b79f9ff3e9f8ce771d7222e25d11c78dca1c4cc5a21d7beba8820e14a545a747bd83512b4486ea868e7005de7770e5fb60b9d2fe8621a06efb9069f69df55cdb4b8683a9b34ded8d5901910bdfcc6dcd263d17a2b8fb4f9f477ef8f57e062629c2a218e37d14f4b42d56d42276b41c6ef0951ecc922f6bf3468e675505f43d69071cfcfdd0c165be33eaa356780b10ac0a9549f8a2a44ed0096430c910b3c374b4069de574d2afc7a465712d1de83b951fca1eb3fa08d901bc711e0721e8a791f1e08f8d6f1a91e0d825e8fd11c7c9d63d1a7f45bc77e489ad02a5872fe6c608e92e4b4be409562028e93e85f783324e9b6120114025a6d25ca39bf8cb88102a7f17f19a982e2c9d18feb916a16a2aa642e9315a75ad605c323e07c489ffba63d652530d1979b07a576e18dbf42658ea1fc60297658f7233669a32647c9862f8e93f9b83b95b129779d62dbed46c73832bdbdac0efd82276259a289a6b225619f8b42e168a834b03df43f8df96582478e6e48f901547d76ba25c365307330c6bd2484b1b32ef859c6261c9bb26ff630e0dc6fd09c1861941c6290a800de0923dc686095c9f5af48ef46d6957cd53a075b9ddfac7e0266c2870df4a6c5e6fd6e811252c9c7550a9954d8487850504d3c9137e5f4fccc215d86308244250ba4d381b44d65937979b6cc697369412bc8e1260e678218d25773f00214d95ed1427e15e709d41dd769daa61e60791eaa362673fc1ed4e4d2cf3dffdceb318a23b9cda940310a159bed8a7a4b5b0e30ca0539db17340ea9ea2fd88566c177165620d32a430f31883fa627f00ff33d4c29393111c8344ebbc8d04f850fab0d43a064cee785afc73c57fa7615deb597355fca0cb0c84907508683d8bd5039b5f968dae15df3b443f1df92532a344dfdfbb65c71d32bca9fd0c6cabbad94b7e6f2da19311f4d8a5f9aa5eb11cb9754233f1618dfdbf9da529d41a56c948d03b5fbfdd46ee501334ae3d8b6d6e6bdf10a014c2e934218a428dff13049996d6005187f95954354de2c6e86de99ceb2f212374df2662d1772d2f3363a3cbf2cf278cdc9b408e76a2ffc3978a54f6aa79d01ec9ccf25b53f80f6d82896a68a17d63fdf2b0fd8281dd9964995fc2b1ffbdae1ee1b21c49c1c7f2b1ead05a1feb1b4ebe1770d2beb3f423703641db4faa2970d03898320ef77bfd33471e6fc9477d895475627620141e04d6db6e7d582e2a1a6705802654ec016ed44da6abb23ab75c4efbc4b079d596dc1c914d44319c3f9ac12e29017745369d542b837a71f1aae9183e0deab1a9e3c0a8bc882ec097fbf71a5ff7af0a35739df87078b7cd8a9f83ca70b93ee481d47fe176b567cfd0d54ab7ebfd10711985ab8a9b1f2d5cd997032fe06eb6819566a0aeb93385f31640b449d66244630a5b07a988fd742398239e4055307dc390d5d0a4a1fe20e73613344f114d3f854b1a262327ddffcf780d63e91a38670c97da89134aa9040c77a97a51818d0dc028654a94675687262bf47ec59f1802d8c960f621f98a4c497aadd2e8602e712ad8a54a48be488a4e5928db7852a0f132c26794be51f5dc04aa49f6b60ea6af26f9e7b35d5c2673f3cf93abdd5d833d43d526b05326ced8ef968680095ef95706eee9c520e10de96c03b93da4a62a84c7aafc2980be7951898896efb6f26d3434f221304abed2f94c199e930a00b77b52efd91e1b7e7ee2875493184cea4a4572354d907d1f949f010f525376ad6c7c1eb373f9f2eed7625a9d1f67eb88bd912029cea95bd3039285db2ce197fe093e4e1bc2c0f22a16adb6949853dd4548967c308f670ac997167ce10c2af2840e7b34b5ebc48381244a8b91eea2e57f786ed9e9e31e668d5f381206a38e6e3c8e73b142e1b1cae2a14e742962567a183d68b1aa5f53aa14d01e4f4deae3f7fbf3562f5ae187b0cf7888b66750d6e9ba5095bf2fc9d4530eadbf74f6a2b88e0894f42ab1d3047458e238d13f350805553f22d40d0043462b5c23b074f803862cffa884e6f6b26a1fee3ca5e566a9cdd45f542aaa7ac31a1f096ba135ea724cf41b60b837c952e187fd219e3461f5677117bef09e819a458cfba78190ebff79039b2f491c0dd4f2db06832c23b12eeab7f981a0778eca0cb45810238694e20b4bf587859f903153da7cd971679b2c4841b02e57b9a174bb57e5bde2780a2a62ed30dd83e31a1da9a91145473400de2b8e184241326a8da0e312ffdca3d05a7c2923e4d414ae0fca89fe074f988ef1afd3585e4e4b31881fb55d85c503ec3fa0f04bad8ac0498552ed800bf239ffde59b2af99d97bdc83f067416c12b30f21c2ff6f4bef06720633fc5498c36ea2d796e9efbe802592a53ec01f9edca6cdafff63c308254f041a7c70410525faf88f9bb251abb78a8763e91ad36e3410cf77e7c2d2eea57708f1dcdae5d9e1183747941b5e0f679c6945fcbac62da6dbb50e3ab1336edcd525860576d573f5c40e2679943aa86e5a007b875fdbf82fede967008d669ac725343f43705bb8efbbc0a6d19b0e77862b26d4a3b24383d00c51876530d1a098ba902a45b82b4a173654d06fa23cbd2a0fdab0702833729ddc73262d5322d01916cea3efbfb58705d5f6ca4a45e2b7f48b7e5fae9ada275390489fd7e02b95c5e65f7d1ebbd2b72f836ca9e7c039305e74c12c6021028ca1c0e4169cb4c76c295c04978fd4ef1c7169ae01f8392e89a129a35ebf3210b961a5a1b0203eaea7f724f4d120048eb288a0ef514aa8fcf62f8239f48d5081cea927fea1e252b1378b3ce0729fe8b98db9ee58bc4b44435cd62b9ae6543b8237c2b93601085bf89e0b65f0f50d7f62e0c78e79557031b818673e05170b75c5a986e4df07d0e1904d11f1fc9ffe2c2238684fc4dc6dea87a07692fd365ffaf41e267222685766117c244e869b1079b46592b55dd4b8bd514d89966db2c9f457970698c47f7be9c34cfd417f1462ac38e1fe83c581c06ffc980c24b11a8e3a84a7d14e120bc7e24e2e60c9babc0c8ce98ad059668ad34fb605c73289097af5c5c1f0d4913cb01a420bd4a9c117eb5c8c0fac76eae6c2c5c5d0f5f39a6fa9d0c10a2cd054ce57ac008b5e0f4bc65283d6135ea4e1724b07c9eeae5331554c64197f29c92b2c9e4b9c550fcc5a46303328d514afa9e1aa9d65320170e8b3825493d374e5c43304f1604d1d48f758022b30b6ad5ce70133a17d2889768386c517bccd1563d12f0d28afae33a7a3181a7466b68198064a071f28222617d99e8a63b9981819c55803ee712bc222fa4c1e45820a5b53e8c321bada8e8a2e11f5e08336f81790168aa8397ea28ad258c9438e149d16307dccc36e15709703836a1beea5cc33a36eb77fd8fdb17a163f3ef491fea89c8519903f3e35536011da6fbf8569a439a43cc8d1cf3474f0f6b0894187f1ce5269805c5db31796409143f668e52a3b61c46178a9cf459928e7f517712780f476e8a5a520c1b75c4725679984c1ce67960e11cf5a9ef93c12aa299eaa0f8d2e4048d3218594bcab0b83b8b4d4867595c15fd5724413f","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2d24f42dc0781afd882a4762881bfaef"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
